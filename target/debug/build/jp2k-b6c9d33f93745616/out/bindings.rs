/* automatically generated by rust-bindgen */

pub const OPJ_TRUE: u32 = 1;
pub const OPJ_FALSE: u32 = 0;
pub const OPJ_HAVE_STDINT_H: u32 = 1;
pub const OPJ_VERSION_MAJOR: u32 = 2;
pub const OPJ_VERSION_MINOR: u32 = 5;
pub const OPJ_VERSION_BUILD: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const OPJ_PATH_LEN: u32 = 4096;
pub const OPJ_J2K_MAXRLVLS: u32 = 33;
pub const OPJ_J2K_MAXBANDS: u32 = 97;
pub const OPJ_J2K_DEFAULT_NB_SEGS: u32 = 10;
pub const OPJ_J2K_STREAM_CHUNK_SIZE: u32 = 1048576;
pub const OPJ_J2K_DEFAULT_HEADER_SIZE: u32 = 1000;
pub const OPJ_J2K_MCC_DEFAULT_NB_RECORDS: u32 = 10;
pub const OPJ_J2K_MCT_DEFAULT_NB_RECORDS: u32 = 10;
pub const JPWL_MAX_NO_TILESPECS: u32 = 16;
pub const JPWL_MAX_NO_PACKSPECS: u32 = 16;
pub const JPWL_MAX_NO_MARKERS: u32 = 512;
pub const JPWL_PRIVATEINDEX_NAME: &'static [u8; 27usize] = b"jpwl_index_privatefilename\0";
pub const JPWL_EXPECTED_COMPONENTS: u32 = 3;
pub const JPWL_MAXIMUM_TILES: u32 = 8192;
pub const JPWL_MAXIMUM_HAMMING: u32 = 2;
pub const JPWL_MAXIMUM_EPB_ROOM: u32 = 65450;
pub const OPJ_IMG_INFO: u32 = 1;
pub const OPJ_J2K_MH_INFO: u32 = 2;
pub const OPJ_J2K_TH_INFO: u32 = 4;
pub const OPJ_J2K_TCH_INFO: u32 = 8;
pub const OPJ_J2K_MH_IND: u32 = 16;
pub const OPJ_J2K_TH_IND: u32 = 32;
pub const OPJ_JP2_INFO: u32 = 128;
pub const OPJ_JP2_IND: u32 = 256;
pub const OPJ_PROFILE_NONE: u32 = 0;
pub const OPJ_PROFILE_0: u32 = 1;
pub const OPJ_PROFILE_1: u32 = 2;
pub const OPJ_PROFILE_PART2: u32 = 32768;
pub const OPJ_PROFILE_CINEMA_2K: u32 = 3;
pub const OPJ_PROFILE_CINEMA_4K: u32 = 4;
pub const OPJ_PROFILE_CINEMA_S2K: u32 = 5;
pub const OPJ_PROFILE_CINEMA_S4K: u32 = 6;
pub const OPJ_PROFILE_CINEMA_LTS: u32 = 7;
pub const OPJ_PROFILE_BC_SINGLE: u32 = 256;
pub const OPJ_PROFILE_BC_MULTI: u32 = 512;
pub const OPJ_PROFILE_BC_MULTI_R: u32 = 768;
pub const OPJ_PROFILE_IMF_2K: u32 = 1024;
pub const OPJ_PROFILE_IMF_4K: u32 = 1280;
pub const OPJ_PROFILE_IMF_8K: u32 = 1536;
pub const OPJ_PROFILE_IMF_2K_R: u32 = 1792;
pub const OPJ_PROFILE_IMF_4K_R: u32 = 2048;
pub const OPJ_PROFILE_IMF_8K_R: u32 = 2304;
pub const OPJ_EXTENSION_NONE: u32 = 0;
pub const OPJ_EXTENSION_MCT: u32 = 256;
pub const OPJ_IMF_MAINLEVEL_MAX: u32 = 11;
pub const OPJ_IMF_MAINLEVEL_1_MSAMPLESEC: u32 = 65;
pub const OPJ_IMF_MAINLEVEL_2_MSAMPLESEC: u32 = 130;
pub const OPJ_IMF_MAINLEVEL_3_MSAMPLESEC: u32 = 195;
pub const OPJ_IMF_MAINLEVEL_4_MSAMPLESEC: u32 = 260;
pub const OPJ_IMF_MAINLEVEL_5_MSAMPLESEC: u32 = 520;
pub const OPJ_IMF_MAINLEVEL_6_MSAMPLESEC: u32 = 1200;
pub const OPJ_IMF_MAINLEVEL_7_MSAMPLESEC: u32 = 2400;
pub const OPJ_IMF_MAINLEVEL_8_MSAMPLESEC: u32 = 4800;
pub const OPJ_IMF_MAINLEVEL_9_MSAMPLESEC: u32 = 9600;
pub const OPJ_IMF_MAINLEVEL_10_MSAMPLESEC: u32 = 19200;
pub const OPJ_IMF_MAINLEVEL_11_MSAMPLESEC: u32 = 38400;
pub const OPJ_IMF_SUBLEVEL_1_MBITSSEC: u32 = 200;
pub const OPJ_IMF_SUBLEVEL_2_MBITSSEC: u32 = 400;
pub const OPJ_IMF_SUBLEVEL_3_MBITSSEC: u32 = 800;
pub const OPJ_IMF_SUBLEVEL_4_MBITSSEC: u32 = 1600;
pub const OPJ_IMF_SUBLEVEL_5_MBITSSEC: u32 = 3200;
pub const OPJ_IMF_SUBLEVEL_6_MBITSSEC: u32 = 6400;
pub const OPJ_IMF_SUBLEVEL_7_MBITSSEC: u32 = 12800;
pub const OPJ_IMF_SUBLEVEL_8_MBITSSEC: u32 = 25600;
pub const OPJ_IMF_SUBLEVEL_9_MBITSSEC: u32 = 51200;
pub const OPJ_CINEMA_24_CS: u32 = 1302083;
pub const OPJ_CINEMA_48_CS: u32 = 651041;
pub const OPJ_CINEMA_24_COMP: u32 = 1041666;
pub const OPJ_CINEMA_48_COMP: u32 = 520833;
pub const OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG: u32 = 1;
pub const OPJ_DPARAMETERS_DUMP_FLAG: u32 = 2;
pub const OPJ_STREAM_READ: u32 = 1;
pub const OPJ_STREAM_WRITE: u32 = 0;
pub type OPJ_BOOL = ::std::os::raw::c_int;
pub type OPJ_CHAR = ::std::os::raw::c_char;
pub type OPJ_FLOAT32 = f32;
pub type OPJ_FLOAT64 = f64;
pub type OPJ_BYTE = ::std::os::raw::c_uchar;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t {{ union }}")
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_attr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_attr_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_cond_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_mutex_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_rwlock_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_rwlock_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_t {{ __sig: {:?}, __cleanup_stack: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__cleanup_stack,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type OPJ_INT8 = i8;
pub type OPJ_UINT8 = u8;
pub type OPJ_INT16 = i16;
pub type OPJ_UINT16 = u16;
pub type OPJ_INT32 = i32;
pub type OPJ_UINT32 = u32;
pub type OPJ_INT64 = i64;
pub type OPJ_UINT64 = u64;
pub type OPJ_OFF_T = i64;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type OPJ_SIZE_T = usize;
#[repr(u32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Rsiz Capabilities"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    #[doc = " Standard JPEG2000 profile"]
    OPJ_CINEMA2K = 3,
    #[doc = " Profile name for a 2K image"]
    OPJ_CINEMA4K = 4,
    #[doc = " Profile name for a 4K image"]
    OPJ_MCT = 33024,
}
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Rsiz Capabilities"]
pub use self::RSIZ_CAPABILITIES as OPJ_RSIZ_CAPABILITIES;
#[repr(u32)]
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Digital cinema operation mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CINEMA_MODE {
    OPJ_OFF = 0,
    #[doc = " Not Digital Cinema"]
    OPJ_CINEMA2K_24 = 1,
    #[doc = " 2K Digital Cinema at 24 fps"]
    OPJ_CINEMA2K_48 = 2,
    #[doc = " 2K Digital Cinema at 48 fps"]
    OPJ_CINEMA4K_24 = 3,
}
#[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
#[doc = " Digital cinema operation mode"]
pub use self::CINEMA_MODE as OPJ_CINEMA_MODE;
#[repr(i32)]
#[doc = " Progression order"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PROG_ORDER {
    #[doc = "< place-holder"]
    OPJ_PROG_UNKNOWN = -1,
    #[doc = "< layer-resolution-component-precinct order"]
    OPJ_LRCP = 0,
    #[doc = "< resolution-layer-component-precinct order"]
    OPJ_RLCP = 1,
    #[doc = "< resolution-precinct-component-layer order"]
    OPJ_RPCL = 2,
    #[doc = "< precinct-component-resolution-layer order"]
    OPJ_PCRL = 3,
    #[doc = "< component-precinct-resolution-layer order"]
    OPJ_CPRL = 4,
}
#[doc = " Progression order"]
pub use self::PROG_ORDER as OPJ_PROG_ORDER;
#[repr(i32)]
#[doc = " Supported image color spaces"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum COLOR_SPACE {
    #[doc = "< not supported by the library"]
    OPJ_CLRSPC_UNKNOWN = -1,
    #[doc = "< not specified in the codestream"]
    OPJ_CLRSPC_UNSPECIFIED = 0,
    #[doc = "< sRGB"]
    OPJ_CLRSPC_SRGB = 1,
    #[doc = "< grayscale"]
    OPJ_CLRSPC_GRAY = 2,
    #[doc = "< YUV"]
    OPJ_CLRSPC_SYCC = 3,
    #[doc = "< e-YCC"]
    OPJ_CLRSPC_EYCC = 4,
    #[doc = "< CMYK"]
    OPJ_CLRSPC_CMYK = 5,
}
#[doc = " Supported image color spaces"]
pub use self::COLOR_SPACE as OPJ_COLOR_SPACE;
#[repr(i32)]
#[doc = " Supported codec"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CODEC_FORMAT {
    #[doc = "< place-holder"]
    OPJ_CODEC_UNKNOWN = -1,
    #[doc = "< JPEG-2000 codestream : read/write"]
    OPJ_CODEC_J2K = 0,
    #[doc = "< JPT-stream (JPEG 2000, JPIP) : read only"]
    OPJ_CODEC_JPT = 1,
    #[doc = "< JP2 file format : read/write"]
    OPJ_CODEC_JP2 = 2,
    #[doc = "< JPP-stream (JPEG 2000, JPIP) : to be coded"]
    OPJ_CODEC_JPP = 3,
    #[doc = "< JPX file format (JPEG 2000 Part-2) : to be coded"]
    OPJ_CODEC_JPX = 4,
}
#[doc = " Supported codec"]
pub use self::CODEC_FORMAT as OPJ_CODEC_FORMAT;
#[doc = " Callback function prototype for events"]
#[doc = " @param msg               Event message"]
#[doc = " @param client_data       Client object where will be return the event message"]
pub type opj_msg_callback = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const ::std::os::raw::c_char,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Progression order changes"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_poc {
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub resno0: OPJ_UINT32,
    #[doc = " Resolution num start, Component num start, given by POC"]
    pub compno0: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub layno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub resno1: OPJ_UINT32,
    #[doc = " Layer num end,Resolution num end, Component num end, given by POC"]
    pub compno1: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub layno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno0: OPJ_UINT32,
    #[doc = " Layer num start,Precinct num start, Precinct num end"]
    pub precno1: OPJ_UINT32,
    #[doc = " Progression order enum"]
    pub prg1: OPJ_PROG_ORDER,
    #[doc = " Progression order enum"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " Progression order string"]
    pub progorder: [OPJ_CHAR; 5usize],
    #[doc = " Tile number (starting at 1)"]
    pub tile: OPJ_UINT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub tx1: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty0: OPJ_INT32,
    #[doc = " Start and end values for Tile width and height"]
    pub ty1: OPJ_INT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub layS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub resS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub compS: OPJ_UINT32,
    #[doc = " Start value, initialised in pi_initialise_encode"]
    pub prcS: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub layE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub resE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub compE: OPJ_UINT32,
    #[doc = " End value, initialised in pi_initialise_encode"]
    pub prcE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyS: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyE: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dx: OPJ_UINT32,
    #[doc = " Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dy: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub lay_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub res_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub comp_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub prc_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub tx0_t: OPJ_UINT32,
    #[doc = " Temporary values for Tile parts, initialised in pi_create_encode"]
    pub ty0_t: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_poc() {
    assert_eq!(
        ::std::mem::size_of::<opj_poc>(),
        148usize,
        concat!("Size of: ", stringify!(opj_poc))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_poc>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_poc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resno0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(resno0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compno0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(compno0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layno1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(layno1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resno1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(resno1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compno1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(compno1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layno0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(layno0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).precno0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(precno0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).precno1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(precno1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prg1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(prg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prg as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(prg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).progorder as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(progorder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tile as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx0 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tx0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tx1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty0 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(ty0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(ty1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layS as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(layS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resS as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(resS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compS as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(compS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prcS as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(prcS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).layE as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(layE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).resE as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(resE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).compE as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(compE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prcE as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(prcE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).txS as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(txS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).txE as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(txE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tyS as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tyS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tyE as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tyE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).dx as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).dy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).lay_t as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(lay_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).res_t as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(res_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).comp_t as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(comp_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).prc_t as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(prc_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).tx0_t as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(tx0_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_poc>())).ty0_t as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_poc),
            "::",
            stringify!(ty0_t)
        )
    );
}
#[doc = " Progression order changes"]
#[doc = ""]
pub type opj_poc_t = opj_poc;
#[doc = " Compression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_cparameters {
    #[doc = " size of tile: tile_size_on = false (not in argument) or = true (in argument)"]
    pub tile_size_on: OPJ_BOOL,
    #[doc = " XTOsiz"]
    pub cp_tx0: ::std::os::raw::c_int,
    #[doc = " YTOsiz"]
    pub cp_ty0: ::std::os::raw::c_int,
    #[doc = " XTsiz"]
    pub cp_tdx: ::std::os::raw::c_int,
    #[doc = " YTsiz"]
    pub cp_tdy: ::std::os::raw::c_int,
    #[doc = " allocation by rate/distortion"]
    pub cp_disto_alloc: ::std::os::raw::c_int,
    #[doc = " allocation by fixed layer"]
    pub cp_fixed_alloc: ::std::os::raw::c_int,
    #[doc = " add fixed_quality"]
    pub cp_fixed_quality: ::std::os::raw::c_int,
    #[doc = " fixed layer"]
    pub cp_matrice: *mut ::std::os::raw::c_int,
    #[doc = " comment for coding"]
    pub cp_comment: *mut ::std::os::raw::c_char,
    #[doc = " csty : coding style"]
    pub csty: ::std::os::raw::c_int,
    #[doc = " progression order (default OPJ_LRCP)"]
    pub prog_order: OPJ_PROG_ORDER,
    #[doc = " progression order changes"]
    pub POC: [opj_poc_t; 32usize],
    #[doc = " number of progression order changes (POC), default to 0"]
    pub numpocs: OPJ_UINT32,
    #[doc = " number of layers"]
    pub tcp_numlayers: ::std::os::raw::c_int,
    #[doc = " rates of layers - might be subsequently limited by the max_cs_size field."]
    #[doc = " Should be decreasing. 1 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_rates: [f32; 100usize],
    #[doc = " different psnr for successive layers. Should be increasing. 0 can be"]
    #[doc = " used as last value to indicate the last layer is lossless."]
    pub tcp_distoratio: [f32; 100usize],
    #[doc = " number of resolutions"]
    pub numresolution: ::std::os::raw::c_int,
    #[doc = " initial code block width, default to 64"]
    pub cblockw_init: ::std::os::raw::c_int,
    #[doc = " initial code block height, default to 64"]
    pub cblockh_init: ::std::os::raw::c_int,
    #[doc = " mode switch (cblk_style)"]
    pub mode: ::std::os::raw::c_int,
    #[doc = " 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default)"]
    pub irreversible: ::std::os::raw::c_int,
    #[doc = " region of interest: affected component in [0..3], -1 means no ROI"]
    pub roi_compno: ::std::os::raw::c_int,
    #[doc = " region of interest: upshift value"]
    pub roi_shift: ::std::os::raw::c_int,
    pub res_spec: ::std::os::raw::c_int,
    #[doc = " initial precinct width"]
    pub prcw_init: [::std::os::raw::c_int; 33usize],
    #[doc = " initial precinct height"]
    pub prch_init: [::std::os::raw::c_int; 33usize],
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " DEPRECATED. Index generation is now handled with the opj_encode_with_info() function. Set to NULL"]
    pub index_on: ::std::os::raw::c_int,
    #[doc = " DEPRECATED. Index generation is now handled with the opj_encode_with_info() function. Set to NULL"]
    pub index: [::std::os::raw::c_char; 4096usize],
    #[doc = " subimage encoding: origin image offset in x direction"]
    pub image_offset_x0: ::std::os::raw::c_int,
    #[doc = " subimage encoding: origin image offset in y direction"]
    pub image_offset_y0: ::std::os::raw::c_int,
    #[doc = " subsampling value for dx"]
    pub subsampling_dx: ::std::os::raw::c_int,
    #[doc = " subsampling value for dy"]
    pub subsampling_dy: ::std::os::raw::c_int,
    #[doc = " input file format 0: PGX, 1: PxM, 2: BMP 3:TIF"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = " output file format 0: J2K, 1: JP2, 2: JPT"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = " enables writing of EPC in MH, thus activating JPWL"]
    pub jpwl_epc_on: OPJ_BOOL,
    #[doc = " error protection method for MH (0,1,16,32,37-128)"]
    pub jpwl_hprot_MH: ::std::os::raw::c_int,
    #[doc = " tile number of header protection specification (>=0)"]
    pub jpwl_hprot_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " error protection methods for TPHs (0,1,16,32,37-128)"]
    pub jpwl_hprot_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = " tile number of packet protection specification (>=0)"]
    pub jpwl_pprot_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " packet number of packet protection specification (>=0)"]
    pub jpwl_pprot_packno: [::std::os::raw::c_int; 16usize],
    #[doc = " error protection methods for packets (0,1,16,32,37-128)"]
    pub jpwl_pprot: [::std::os::raw::c_int; 16usize],
    #[doc = " enables writing of ESD, (0=no/1/2 bytes)"]
    pub jpwl_sens_size: ::std::os::raw::c_int,
    #[doc = " sensitivity addressing size (0=auto/2/4 bytes)"]
    pub jpwl_sens_addr: ::std::os::raw::c_int,
    #[doc = " sensitivity range (0-3)"]
    pub jpwl_sens_range: ::std::os::raw::c_int,
    #[doc = " sensitivity method for MH (-1=no,0-7)"]
    pub jpwl_sens_MH: ::std::os::raw::c_int,
    #[doc = " tile number of sensitivity specification (>=0)"]
    pub jpwl_sens_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = " sensitivity methods for TPHs (-1=no,0-7)"]
    pub jpwl_sens_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and MAX_COMP_SIZE instead"]
    #[doc = " Digital Cinema compliance 0-not compliant, 1-compliant"]
    pub cp_cinema: OPJ_CINEMA_MODE,
    #[doc = " Maximum size (in bytes) for each component."]
    #[doc = " If == 0, component size limitation is not considered"]
    pub max_comp_size: ::std::os::raw::c_int,
    #[doc = " DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead"]
    #[doc = " Profile name"]
    pub cp_rsiz: OPJ_RSIZ_CAPABILITIES,
    #[doc = " Tile part generation"]
    pub tp_on: ::std::os::raw::c_char,
    #[doc = " Flag for Tile part generation"]
    pub tp_flag: ::std::os::raw::c_char,
    #[doc = " MCT (multiple component transform)"]
    pub tcp_mct: ::std::os::raw::c_char,
    #[doc = " Enable JPIP indexing"]
    pub jpip_on: OPJ_BOOL,
    #[doc = " Naive implementation of MCT restricted to a single reversible array based"]
    #[doc = "encoding without offset concerning all the components."]
    pub mct_data: *mut ::std::os::raw::c_void,
    #[doc = " Maximum size (in bytes) for the whole codestream."]
    #[doc = " If == 0, codestream size limitation is not considered"]
    #[doc = " If it does not comply with tcp_rates, max_cs_size prevails"]
    #[doc = " and a warning is issued."]
    pub max_cs_size: ::std::os::raw::c_int,
    #[doc = " RSIZ value"]
    #[doc = "To be used to combine OPJ_PROFILE_*, OPJ_EXTENSION_* and (sub)levels values."]
    pub rsiz: OPJ_UINT16,
}
#[test]
fn bindgen_test_layout_opj_cparameters() {
    assert_eq!(
        ::std::mem::size_of::<opj_cparameters>(),
        18720usize,
        concat!("Size of: ", stringify!(opj_cparameters))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_cparameters>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_cparameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tile_size_on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tile_size_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tx0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_tx0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_ty0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_ty0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tdx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_tdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_tdy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_tdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_disto_alloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_disto_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_fixed_alloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_fixed_alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).cp_fixed_quality as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_fixed_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_matrice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_matrice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_comment as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).csty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(csty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prog_order as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(prog_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).POC as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(POC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).numpocs as *const _ as usize },
        4792usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(numpocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_numlayers as *const _ as usize },
        4796usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tcp_numlayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_rates as *const _ as usize },
        4800usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tcp_rates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_distoratio as *const _ as usize },
        5200usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tcp_distoratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).numresolution as *const _ as usize },
        5600usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(numresolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cblockw_init as *const _ as usize },
        5604usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cblockw_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cblockh_init as *const _ as usize },
        5608usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cblockh_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).mode as *const _ as usize },
        5612usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).irreversible as *const _ as usize },
        5616usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(irreversible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).roi_compno as *const _ as usize },
        5620usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(roi_compno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).roi_shift as *const _ as usize },
        5624usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(roi_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).res_spec as *const _ as usize },
        5628usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(res_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prcw_init as *const _ as usize },
        5632usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(prcw_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).prch_init as *const _ as usize },
        5764usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(prch_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).infile as *const _ as usize },
        5896usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(infile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).outfile as *const _ as usize },
        9992usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(outfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).index_on as *const _ as usize },
        14088usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(index_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).index as *const _ as usize },
        14092usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).image_offset_x0 as *const _ as usize },
        18188usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(image_offset_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).image_offset_y0 as *const _ as usize },
        18192usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(image_offset_y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).subsampling_dx as *const _ as usize },
        18196usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(subsampling_dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).subsampling_dy as *const _ as usize },
        18200usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(subsampling_dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).decod_format as *const _ as usize },
        18204usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(decod_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cod_format as *const _ as usize },
        18208usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cod_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_epc_on as *const _ as usize },
        18212usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_epc_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_MH as *const _ as usize },
        18216usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_hprot_MH)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_TPH_tileno as *const _ as usize
        },
        18220usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_hprot_TPH_tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_hprot_TPH as *const _ as usize },
        18284usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_hprot_TPH)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot_tileno as *const _ as usize
        },
        18348usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_pprot_tileno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot_packno as *const _ as usize
        },
        18412usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_pprot_packno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_pprot as *const _ as usize },
        18476usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_pprot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_size as *const _ as usize },
        18540usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_addr as *const _ as usize },
        18544usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_range as *const _ as usize },
        18548usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_MH as *const _ as usize },
        18552usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_MH)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_TPH_tileno as *const _ as usize
        },
        18556usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_TPH_tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpwl_sens_TPH as *const _ as usize },
        18620usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpwl_sens_TPH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_cinema as *const _ as usize },
        18684usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_cinema)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).max_comp_size as *const _ as usize },
        18688usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(max_comp_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).cp_rsiz as *const _ as usize },
        18692usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(cp_rsiz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tp_on as *const _ as usize },
        18696usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tp_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tp_flag as *const _ as usize },
        18697usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tp_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).tcp_mct as *const _ as usize },
        18698usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(tcp_mct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).jpip_on as *const _ as usize },
        18700usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(jpip_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).mct_data as *const _ as usize },
        18704usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(mct_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).max_cs_size as *const _ as usize },
        18712usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(max_cs_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_cparameters>())).rsiz as *const _ as usize },
        18716usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_cparameters),
            "::",
            stringify!(rsiz)
        )
    );
}
impl ::std::fmt::Debug for opj_cparameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "opj_cparameters {{ tile_size_on: {:?}, cp_tx0: {:?}, cp_ty0: {:?}, cp_tdx: {:?}, cp_tdy: {:?}, cp_disto_alloc: {:?}, cp_fixed_alloc: {:?}, cp_fixed_quality: {:?}, cp_matrice: {:?}, cp_comment: {:?}, csty: {:?}, prog_order: {:?}, POC: [{}], numpocs: {:?}, tcp_numlayers: {:?}, tcp_rates: [{}], tcp_distoratio: [{}], numresolution: {:?}, cblockw_init: {:?}, cblockh_init: {:?}, mode: {:?}, irreversible: {:?}, roi_compno: {:?}, roi_shift: {:?}, res_spec: {:?}, prcw_init: [{}], prch_init: [{}], infile: [{}], outfile: [{}], index_on: {:?}, index: [{}], image_offset_x0: {:?}, image_offset_y0: {:?}, subsampling_dx: {:?}, subsampling_dy: {:?}, decod_format: {:?}, cod_format: {:?}, jpwl_epc_on: {:?}, jpwl_hprot_MH: {:?}, jpwl_hprot_TPH_tileno: {:?}, jpwl_hprot_TPH: {:?}, jpwl_pprot_tileno: {:?}, jpwl_pprot_packno: {:?}, jpwl_pprot: {:?}, jpwl_sens_size: {:?}, jpwl_sens_addr: {:?}, jpwl_sens_range: {:?}, jpwl_sens_MH: {:?}, jpwl_sens_TPH_tileno: {:?}, jpwl_sens_TPH: {:?}, cp_cinema: {:?}, max_comp_size: {:?}, cp_rsiz: {:?}, tp_on: {:?}, tp_flag: {:?}, tcp_mct: {:?}, jpip_on: {:?}, mct_data: {:?}, max_cs_size: {:?}, rsiz: {:?} }}" , self . tile_size_on , self . cp_tx0 , self . cp_ty0 , self . cp_tdx , self . cp_tdy , self . cp_disto_alloc , self . cp_fixed_alloc , self . cp_fixed_quality , self . cp_matrice , self . cp_comment , self . csty , self . prog_order , self . POC . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . numpocs , self . tcp_numlayers , self . tcp_rates . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . tcp_distoratio . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . numresolution , self . cblockw_init , self . cblockh_init , self . mode , self . irreversible , self . roi_compno , self . roi_shift , self . res_spec , self . prcw_init . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . prch_init . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . infile . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . outfile . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . index_on , self . index . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . image_offset_x0 , self . image_offset_y0 , self . subsampling_dx , self . subsampling_dy , self . decod_format , self . cod_format , self . jpwl_epc_on , self . jpwl_hprot_MH , self . jpwl_hprot_TPH_tileno , self . jpwl_hprot_TPH , self . jpwl_pprot_tileno , self . jpwl_pprot_packno , self . jpwl_pprot , self . jpwl_sens_size , self . jpwl_sens_addr , self . jpwl_sens_range , self . jpwl_sens_MH , self . jpwl_sens_TPH_tileno , self . jpwl_sens_TPH , self . cp_cinema , self . max_comp_size , self . cp_rsiz , self . tp_on , self . tp_flag , self . tcp_mct , self . jpip_on , self . mct_data , self . max_cs_size , self . rsiz)
    }
}
#[doc = " Compression parameters"]
pub type opj_cparameters_t = opj_cparameters;
#[doc = " Decompression parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_dparameters {
    #[doc = "Set the number of highest resolution levels to be discarded."]
    #[doc = "The image resolution is effectively divided by 2 to the power of the number of discarded levels."]
    #[doc = "The reduce factor is limited by the smallest total number of decomposition levels among tiles."]
    #[doc = "if != 0, then original dimension divided by 2^(reduce);"]
    #[doc = "if == 0 or not used, image is decoded to the full resolution"]
    pub cp_reduce: OPJ_UINT32,
    #[doc = "Set the maximum number of quality layers to decode."]
    #[doc = "If there are less quality layers than the specified number, all the quality layers are decoded."]
    #[doc = "if != 0, then only the first \"layer\" layers are decoded;"]
    #[doc = "if == 0 or not used, all the quality layers are decoded"]
    pub cp_layer: OPJ_UINT32,
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " input file format 0: J2K, 1: JP2, 2: JPT"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = " output file format 0: PGX, 1: PxM, 2: BMP"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = " Decoding area left boundary"]
    pub DA_x0: OPJ_UINT32,
    #[doc = " Decoding area right boundary"]
    pub DA_x1: OPJ_UINT32,
    #[doc = " Decoding area up boundary"]
    pub DA_y0: OPJ_UINT32,
    #[doc = " Decoding area bottom boundary"]
    pub DA_y1: OPJ_UINT32,
    #[doc = " Verbose mode"]
    pub m_verbose: OPJ_BOOL,
    #[doc = " tile number of the decoded tile"]
    pub tile_index: OPJ_UINT32,
    #[doc = " Nb of tile to decode"]
    pub nb_tile_to_decode: OPJ_UINT32,
    #[doc = " activates the JPWL correction capabilities"]
    pub jpwl_correct: OPJ_BOOL,
    #[doc = " expected number of components"]
    pub jpwl_exp_comps: ::std::os::raw::c_int,
    #[doc = " maximum number of tiles"]
    pub jpwl_max_tiles: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_opj_dparameters() {
    assert_eq!(
        ::std::mem::size_of::<opj_dparameters>(),
        8252usize,
        concat!("Size of: ", stringify!(opj_dparameters))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_dparameters>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_dparameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cp_reduce as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(cp_reduce)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cp_layer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(cp_layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).infile as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(infile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).outfile as *const _ as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(outfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).decod_format as *const _ as usize },
        8200usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(decod_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).cod_format as *const _ as usize },
        8204usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(cod_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_x0 as *const _ as usize },
        8208usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(DA_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_x1 as *const _ as usize },
        8212usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(DA_x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_y0 as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(DA_y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).DA_y1 as *const _ as usize },
        8220usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(DA_y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).m_verbose as *const _ as usize },
        8224usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(m_verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).tile_index as *const _ as usize },
        8228usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(tile_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_dparameters>())).nb_tile_to_decode as *const _ as usize
        },
        8232usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(nb_tile_to_decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_correct as *const _ as usize },
        8236usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(jpwl_correct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_exp_comps as *const _ as usize },
        8240usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(jpwl_exp_comps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).jpwl_max_tiles as *const _ as usize },
        8244usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(jpwl_max_tiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_dparameters>())).flags as *const _ as usize },
        8248usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_dparameters),
            "::",
            stringify!(flags)
        )
    );
}
impl ::std::fmt::Debug for opj_dparameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "opj_dparameters {{ cp_reduce: {:?}, cp_layer: {:?}, infile: [{}], outfile: [{}], decod_format: {:?}, cod_format: {:?}, DA_x0: {:?}, DA_x1: {:?}, DA_y0: {:?}, DA_y1: {:?}, m_verbose: {:?}, tile_index: {:?}, nb_tile_to_decode: {:?}, jpwl_correct: {:?}, jpwl_exp_comps: {:?}, jpwl_max_tiles: {:?}, flags: {:?} }}" , self . cp_reduce , self . cp_layer , self . infile . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . outfile . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . decod_format , self . cod_format , self . DA_x0 , self . DA_x1 , self . DA_y0 , self . DA_y1 , self . m_verbose , self . tile_index , self . nb_tile_to_decode , self . jpwl_correct , self . jpwl_exp_comps , self . jpwl_max_tiles , self . flags)
    }
}
#[doc = " Decompression parameters"]
pub type opj_dparameters_t = opj_dparameters;
#[doc = " JPEG2000 codec V2."]
pub type opj_codec_t = *mut ::std::os::raw::c_void;
pub type opj_stream_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_skip_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_OFF_T,
>;
pub type opj_stream_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL,
>;
pub type opj_stream_free_user_data_fn =
    ::std::option::Option<unsafe extern "C" fn(p_user_data: *mut ::std::os::raw::c_void)>;
pub type opj_stream_t = *mut ::std::os::raw::c_void;
#[doc = " Defines a single image component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comp {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision: number of bits per component per pixel"]
    pub prec: OPJ_UINT32,
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
    #[doc = " number of decoded resolution"]
    pub resno_decoded: OPJ_UINT32,
    #[doc = " number of division by 2 of the out image compared to the original size of image"]
    pub factor: OPJ_UINT32,
    #[doc = " image component data"]
    pub data: *mut OPJ_INT32,
    #[doc = " alpha channel"]
    pub alpha: OPJ_UINT16,
}
#[test]
fn bindgen_test_layout_opj_image_comp() {
    assert_eq!(
        ::std::mem::size_of::<opj_image_comp>(),
        64usize,
        concat!("Size of: ", stringify!(opj_image_comp))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image_comp>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_image_comp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).dx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).dy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).x0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).y0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).prec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).bpp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).sgnd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(sgnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).resno_decoded as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(resno_decoded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).factor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comp>())).alpha as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comp),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " Defines a single image component"]
pub type opj_image_comp_t = opj_image_comp;
#[doc = " Defines image data and characteristics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image {
    #[doc = " XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area"]
    pub x0: OPJ_UINT32,
    #[doc = " YOsiz: vertical offset from the origin of the reference grid to the top side of the image area"]
    pub y0: OPJ_UINT32,
    #[doc = " Xsiz: width of the reference grid"]
    pub x1: OPJ_UINT32,
    #[doc = " Ysiz: height of the reference grid"]
    pub y1: OPJ_UINT32,
    #[doc = " number of components in the image"]
    pub numcomps: OPJ_UINT32,
    #[doc = " color space: sRGB, Greyscale or YUV"]
    pub color_space: OPJ_COLOR_SPACE,
    #[doc = " image components"]
    pub comps: *mut opj_image_comp_t,
    #[doc = " 'restricted' ICC profile"]
    pub icc_profile_buf: *mut OPJ_BYTE,
    #[doc = " size of ICC profile"]
    pub icc_profile_len: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_image() {
    assert_eq!(
        ::std::mem::size_of::<opj_image>(),
        48usize,
        concat!("Size of: ", stringify!(opj_image))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).y0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).x1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).y1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).numcomps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(numcomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).color_space as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).comps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(comps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).icc_profile_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(icc_profile_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image>())).icc_profile_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image),
            "::",
            stringify!(icc_profile_len)
        )
    );
}
#[doc = " Defines image data and characteristics"]
pub type opj_image_t = opj_image;
#[doc = " Component parameters structure used by the opj_image_create function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comptparm {
    #[doc = " XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = " YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = " data width"]
    pub w: OPJ_UINT32,
    #[doc = " data height"]
    pub h: OPJ_UINT32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = " precision: number of bits per component per pixel"]
    pub prec: OPJ_UINT32,
    pub bpp: OPJ_UINT32,
    #[doc = " signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
}
#[test]
fn bindgen_test_layout_opj_image_comptparm() {
    assert_eq!(
        ::std::mem::size_of::<opj_image_comptparm>(),
        36usize,
        concat!("Size of: ", stringify!(opj_image_comptparm))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_image_comptparm>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_image_comptparm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).dx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).dy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).x0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).y0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).prec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).bpp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_image_comptparm>())).sgnd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_image_comptparm),
            "::",
            stringify!(sgnd)
        )
    );
}
#[doc = " Component parameters structure used by the opj_image_create function"]
pub type opj_image_cmptparm_t = opj_image_comptparm;
#[doc = " Index structure : Information concerning a packet inside tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_packet_info {
    #[doc = " packet start position (including SOP marker if it exists)"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end of packet header position (including EPH marker if it exists)"]
    pub end_ph_pos: OPJ_OFF_T,
    #[doc = " packet end position"]
    pub end_pos: OPJ_OFF_T,
    #[doc = " packet distorsion"]
    pub disto: f64,
}
#[test]
fn bindgen_test_layout_opj_packet_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_packet_info>(),
        32usize,
        concat!("Size of: ", stringify!(opj_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_packet_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).start_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_packet_info),
            "::",
            stringify!(start_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).end_ph_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_packet_info),
            "::",
            stringify!(end_ph_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).end_pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_packet_info),
            "::",
            stringify!(end_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_packet_info>())).disto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_packet_info),
            "::",
            stringify!(disto)
        )
    );
}
#[doc = " Index structure : Information concerning a packet inside tile"]
pub type opj_packet_info_t = opj_packet_info;
#[doc = " Marker structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_marker_info {
    #[doc = " marker type"]
    pub type_: ::std::os::raw::c_ushort,
    #[doc = " position in codestream"]
    pub pos: OPJ_OFF_T,
    #[doc = " length, marker val included"]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opj_marker_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_marker_info>(),
        24usize,
        concat!("Size of: ", stringify!(opj_marker_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_marker_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_marker_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_marker_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_marker_info),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_marker_info>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_marker_info),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Marker structure"]
pub type opj_marker_info_t = opj_marker_info;
#[doc = " Index structure : Information concerning tile-parts"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_info {
    #[doc = " start position of tile part"]
    pub tp_start_pos: ::std::os::raw::c_int,
    #[doc = " end position of tile part header"]
    pub tp_end_header: ::std::os::raw::c_int,
    #[doc = " end position of tile part"]
    pub tp_end_pos: ::std::os::raw::c_int,
    #[doc = " start packet of tile part"]
    pub tp_start_pack: ::std::os::raw::c_int,
    #[doc = " number of packets of tile part"]
    pub tp_numpacks: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opj_tp_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tp_info>(),
        20usize,
        concat!("Size of: ", stringify!(opj_tp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_tp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_start_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_info),
            "::",
            stringify!(tp_start_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_end_header as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_info),
            "::",
            stringify!(tp_end_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_end_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_info),
            "::",
            stringify!(tp_end_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_start_pack as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_info),
            "::",
            stringify!(tp_start_pack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_info>())).tp_numpacks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_info),
            "::",
            stringify!(tp_numpacks)
        )
    );
}
#[doc = " Index structure : Information concerning tile-parts"]
pub type opj_tp_info_t = opj_tp_info;
#[doc = " Index structure : information regarding tiles"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tile_info {
    #[doc = " value of thresh for each layer by tile cfr. Marcela"]
    pub thresh: *mut f64,
    #[doc = " number of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = " start position"]
    pub start_pos: ::std::os::raw::c_int,
    #[doc = " end position of the header"]
    pub end_header: ::std::os::raw::c_int,
    #[doc = " end position"]
    pub end_pos: ::std::os::raw::c_int,
    #[doc = " precinct number for each resolution level (width)"]
    pub pw: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct number for each resolution level (height)"]
    pub ph: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct size (in power of 2), in X for each resolution level"]
    pub pdx: [::std::os::raw::c_int; 33usize],
    #[doc = " precinct size (in power of 2), in Y for each resolution level"]
    pub pdy: [::std::os::raw::c_int; 33usize],
    #[doc = " information concerning packets inside tile"]
    pub packet: *mut opj_packet_info_t,
    #[doc = " add fixed_quality"]
    pub numpix: ::std::os::raw::c_int,
    #[doc = " add fixed_quality"]
    pub distotile: f64,
    #[doc = " number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = " number of tile parts"]
    pub num_tps: ::std::os::raw::c_int,
    #[doc = " information concerning tile parts"]
    pub tp: *mut opj_tp_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_info>(),
        608usize,
        concat!("Size of: ", stringify!(opj_tile_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).tileno as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).start_pos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(start_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).end_header as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(end_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).end_pos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(end_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(pw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).ph as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(ph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pdx as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(pdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).pdy as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(pdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).packet as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).numpix as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(numpix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).distotile as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(distotile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).marknum as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(marknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).marker as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).maxmarknum as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(maxmarknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).num_tps as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(num_tps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_info>())).tp as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_info),
            "::",
            stringify!(tp)
        )
    );
}
impl ::std::fmt::Debug for opj_tile_info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "opj_tile_info {{ thresh: {:?}, tileno: {:?}, start_pos: {:?}, end_header: {:?}, end_pos: {:?}, pw: [{}], ph: [{}], pdx: [{}], pdy: [{}], packet: {:?}, numpix: {:?}, distotile: {:?}, marknum: {:?}, marker: {:?}, maxmarknum: {:?}, num_tps: {:?}, tp: {:?} }}" , self . thresh , self . tileno , self . start_pos , self . end_header , self . end_pos , self . pw . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . ph . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . pdx . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . pdy . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . packet , self . numpix , self . distotile , self . marknum , self . marker , self . maxmarknum , self . num_tps , self . tp)
    }
}
#[doc = " Index structure : information regarding tiles"]
pub type opj_tile_info_t = opj_tile_info;
#[doc = " Index structure of the codestream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info {
    #[doc = " maximum distortion reduction on the whole image (add for Marcela)"]
    pub D_max: f64,
    #[doc = " packet number"]
    pub packno: ::std::os::raw::c_int,
    #[doc = " writing the packet in the index with t2_encode_packets"]
    pub index_write: ::std::os::raw::c_int,
    #[doc = " image width"]
    pub image_w: ::std::os::raw::c_int,
    #[doc = " image height"]
    pub image_h: ::std::os::raw::c_int,
    #[doc = " progression order"]
    pub prog: OPJ_PROG_ORDER,
    #[doc = " tile size in x"]
    pub tile_x: ::std::os::raw::c_int,
    #[doc = " tile size in y"]
    pub tile_y: ::std::os::raw::c_int,
    pub tile_Ox: ::std::os::raw::c_int,
    pub tile_Oy: ::std::os::raw::c_int,
    #[doc = " number of tiles in X"]
    pub tw: ::std::os::raw::c_int,
    #[doc = " number of tiles in Y"]
    pub th: ::std::os::raw::c_int,
    #[doc = " component numbers"]
    pub numcomps: ::std::os::raw::c_int,
    #[doc = " number of layer"]
    pub numlayers: ::std::os::raw::c_int,
    #[doc = " number of decomposition for each component"]
    pub numdecompos: *mut ::std::os::raw::c_int,
    #[doc = " number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = " main header position"]
    pub main_head_start: ::std::os::raw::c_int,
    #[doc = " main header position"]
    pub main_head_end: ::std::os::raw::c_int,
    #[doc = " codestream's size"]
    pub codestream_size: ::std::os::raw::c_int,
    #[doc = " information regarding tiles inside image"]
    pub tile: *mut opj_tile_info_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_info>(),
        112usize,
        concat!("Size of: ", stringify!(opj_codestream_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).D_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(D_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).packno as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(packno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).index_write as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(index_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).image_w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(image_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).image_h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(image_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).prog as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tile_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tile_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_Ox as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tile_Ox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile_Oy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tile_Oy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tw as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).th as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numcomps as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(numcomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numlayers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(numlayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).numdecompos as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(numdecompos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).marknum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(marknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).marker as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).maxmarknum as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(maxmarknum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).main_head_start as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(main_head_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).main_head_end as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(main_head_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info>())).codestream_size as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(codestream_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info>())).tile as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info),
            "::",
            stringify!(tile)
        )
    );
}
#[doc = " Index structure of the codestream"]
pub type opj_codestream_info_t = opj_codestream_info;
#[doc = " Tile-component coding parameters information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct opj_tccp_info {
    #[doc = " component index"]
    pub compno: OPJ_UINT32,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " number of resolutions"]
    pub numresolutions: OPJ_UINT32,
    #[doc = " log2 of code-blocks width"]
    pub cblkw: OPJ_UINT32,
    #[doc = " log2 of code-blocks height"]
    pub cblkh: OPJ_UINT32,
    #[doc = " code-block coding style"]
    pub cblksty: OPJ_UINT32,
    #[doc = " discrete wavelet transform identifier: 0 = 9-7 irreversible, 1 = 5-3 reversible"]
    pub qmfbid: OPJ_UINT32,
    #[doc = " quantisation style"]
    pub qntsty: OPJ_UINT32,
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_mant: [OPJ_UINT32; 97usize],
    #[doc = " stepsizes used for quantization"]
    pub stepsizes_expn: [OPJ_UINT32; 97usize],
    #[doc = " number of guard bits"]
    pub numgbits: OPJ_UINT32,
    #[doc = " Region Of Interest shift"]
    pub roishift: OPJ_INT32,
    #[doc = " precinct width"]
    pub prcw: [OPJ_UINT32; 33usize],
    #[doc = " precinct height"]
    pub prch: [OPJ_UINT32; 33usize],
}
#[test]
fn bindgen_test_layout_opj_tccp_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tccp_info>(),
        1080usize,
        concat!("Size of: ", stringify!(opj_tccp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tccp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_tccp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).compno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(compno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).csty as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(csty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).numresolutions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(numresolutions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblkw as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(cblkw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblkh as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(cblkh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).cblksty as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(cblksty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).qmfbid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(qmfbid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).qntsty as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(qntsty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).stepsizes_mant as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(stepsizes_mant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).stepsizes_expn as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(stepsizes_expn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).numgbits as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(numgbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).roishift as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(roishift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).prcw as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(prcw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tccp_info>())).prch as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tccp_info),
            "::",
            stringify!(prch)
        )
    );
}
impl ::std::fmt::Debug for opj_tccp_info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "opj_tccp_info {{ compno: {:?}, csty: {:?}, numresolutions: {:?}, cblkw: {:?}, cblkh: {:?}, cblksty: {:?}, qmfbid: {:?}, qntsty: {:?}, stepsizes_mant: [{}], stepsizes_expn: [{}], numgbits: {:?}, roishift: {:?}, prcw: [{}], prch: [{}] }}" , self . compno , self . csty , self . numresolutions , self . cblkw , self . cblkh , self . cblksty , self . qmfbid , self . qntsty , self . stepsizes_mant . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . stepsizes_expn . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . numgbits , self . roishift , self . prcw . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > () , self . prch . iter () . enumerate () . map (| (i , v) | format ! ("{}{:?}" , if i > 0 { ", " } else { "" } , v)) . collect :: < String > ())
    }
}
#[doc = " Tile-component coding parameters information"]
pub type opj_tccp_info_t = opj_tccp_info;
#[doc = " Tile coding parameters information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_v2_info {
    #[doc = " number (index) of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = " coding style"]
    pub csty: OPJ_UINT32,
    #[doc = " progression order"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = " number of layers"]
    pub numlayers: OPJ_UINT32,
    #[doc = " multi-component transform identifier"]
    pub mct: OPJ_UINT32,
    #[doc = " information concerning tile component parameters"]
    pub tccp_info: *mut opj_tccp_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_v2_info() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_v2_info>(),
        32usize,
        concat!("Size of: ", stringify!(opj_tile_v2_info))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_v2_info>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_v2_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).tileno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).csty as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(csty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).prg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(prg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).numlayers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(numlayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).mct as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(mct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_v2_info>())).tccp_info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_v2_info),
            "::",
            stringify!(tccp_info)
        )
    );
}
#[doc = " Tile coding parameters information"]
pub type opj_tile_info_v2_t = opj_tile_v2_info;
#[doc = " Information structure about the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info_v2 {
    #[doc = " tile origin in x = XTOsiz"]
    pub tx0: OPJ_UINT32,
    #[doc = " tile origin in y = YTOsiz"]
    pub ty0: OPJ_UINT32,
    #[doc = " tile size in x = XTsiz"]
    pub tdx: OPJ_UINT32,
    #[doc = " tile size in y = YTsiz"]
    pub tdy: OPJ_UINT32,
    #[doc = " number of tiles in X"]
    pub tw: OPJ_UINT32,
    #[doc = " number of tiles in Y"]
    pub th: OPJ_UINT32,
    #[doc = " number of components"]
    pub nbcomps: OPJ_UINT32,
    #[doc = " Default information regarding tiles inside image"]
    pub m_default_tile_info: opj_tile_info_v2_t,
    #[doc = " information regarding tiles inside image"]
    pub tile_info: *mut opj_tile_info_v2_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_info_v2>(),
        72usize,
        concat!("Size of: ", stringify!(opj_codestream_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tx0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tx0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).ty0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(ty0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tdx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tdy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tdy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).tw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).th as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_info_v2>())).nbcomps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(nbcomps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info_v2>())).m_default_tile_info as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(m_default_tile_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_info_v2>())).tile_info as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_info_v2),
            "::",
            stringify!(tile_info)
        )
    );
}
#[doc = " Information structure about the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_info_v2_t = opj_codestream_info_v2;
#[doc = " Index structure about a tile part"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_index {
    #[doc = " start position"]
    pub start_pos: OPJ_OFF_T,
    #[doc = " end position of the header"]
    pub end_header: OPJ_OFF_T,
    #[doc = " end position"]
    pub end_pos: OPJ_OFF_T,
}
#[test]
fn bindgen_test_layout_opj_tp_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_tp_index>(),
        24usize,
        concat!("Size of: ", stringify!(opj_tp_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tp_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tp_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).start_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_index),
            "::",
            stringify!(start_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).end_header as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_index),
            "::",
            stringify!(end_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tp_index>())).end_pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tp_index),
            "::",
            stringify!(end_pos)
        )
    );
}
#[doc = " Index structure about a tile part"]
pub type opj_tp_index_t = opj_tp_index;
#[doc = " Index structure about a tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_index {
    #[doc = " tile index"]
    pub tileno: OPJ_UINT32,
    #[doc = " number of tile parts"]
    pub nb_tps: OPJ_UINT32,
    #[doc = " current nb of tile part (allocated)"]
    pub current_nb_tps: OPJ_UINT32,
    #[doc = " current tile-part index"]
    pub current_tpsno: OPJ_UINT32,
    #[doc = " information concerning tile parts"]
    pub tp_index: *mut opj_tp_index_t,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    #[doc = " packet number"]
    pub nb_packet: OPJ_UINT32,
    #[doc = " information concerning packets inside tile"]
    pub packet_index: *mut opj_packet_info_t,
}
#[test]
fn bindgen_test_layout_opj_tile_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_tile_index>(),
        56usize,
        concat!("Size of: ", stringify!(opj_tile_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_tile_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_tile_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).tileno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(tileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).nb_tps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(nb_tps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).current_nb_tps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(current_nb_tps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).current_tpsno as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(current_tpsno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).tp_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(tp_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).marknum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(marknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).marker as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).maxmarknum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(maxmarknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).nb_packet as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(nb_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_tile_index>())).packet_index as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_tile_index),
            "::",
            stringify!(packet_index)
        )
    );
}
#[doc = " Index structure about a tile"]
pub type opj_tile_index_t = opj_tile_index;
#[doc = " Index structure of the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_index {
    #[doc = " main header start position (SOC position)"]
    pub main_head_start: OPJ_OFF_T,
    #[doc = " main header end position (first SOT position)"]
    pub main_head_end: OPJ_OFF_T,
    #[doc = " codestream's size"]
    pub codestream_size: OPJ_UINT64,
    #[doc = " number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = " list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = " actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    pub nb_of_tiles: OPJ_UINT32,
    pub tile_index: *mut opj_tile_index_t,
}
#[test]
fn bindgen_test_layout_opj_codestream_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_codestream_index>(),
        56usize,
        concat!("Size of: ", stringify!(opj_codestream_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_codestream_index>(),
        8usize,
        concat!("Alignment of ", stringify!(opj_codestream_index))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).main_head_start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(main_head_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).main_head_end as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(main_head_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).codestream_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(codestream_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).marknum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(marknum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).marker as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).maxmarknum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(maxmarknum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opj_codestream_index>())).nb_of_tiles as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(nb_of_tiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_codestream_index>())).tile_index as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_codestream_index),
            "::",
            stringify!(tile_index)
        )
    );
}
#[doc = " Index structure of the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_index_t = opj_codestream_index;
#[doc = " Info structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_metadata {
    pub not_used: OPJ_INT32,
}
#[test]
fn bindgen_test_layout_opj_jp2_metadata() {
    assert_eq!(
        ::std::mem::size_of::<opj_jp2_metadata>(),
        4usize,
        concat!("Size of: ", stringify!(opj_jp2_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_jp2_metadata>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_jp2_metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_jp2_metadata>())).not_used as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_jp2_metadata),
            "::",
            stringify!(not_used)
        )
    );
}
#[doc = " Info structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_metadata_t = opj_jp2_metadata;
#[doc = " Index structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_index {
    pub not_used: OPJ_INT32,
}
#[test]
fn bindgen_test_layout_opj_jp2_index() {
    assert_eq!(
        ::std::mem::size_of::<opj_jp2_index>(),
        4usize,
        concat!("Size of: ", stringify!(opj_jp2_index))
    );
    assert_eq!(
        ::std::mem::align_of::<opj_jp2_index>(),
        4usize,
        concat!("Alignment of ", stringify!(opj_jp2_index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opj_jp2_index>())).not_used as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opj_jp2_index),
            "::",
            stringify!(not_used)
        )
    );
}
#[doc = " Index structure of the JP2 file"]
#[doc = " EXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_index_t = opj_jp2_index;
extern "C" {
    pub fn opj_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an image"]
    #[doc = ""]
    #[doc = " @param numcmpts      number of components"]
    #[doc = " @param cmptparms     components parameters"]
    #[doc = " @param clrspc        image color space"]
    #[doc = " @return returns      a new image structure if successful, returns NULL otherwise"]
    pub fn opj_image_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Deallocate any resources associated with an image"]
    #[doc = ""]
    #[doc = " @param image         image to be destroyed"]
    pub fn opj_image_destroy(image: *mut opj_image_t);
}
extern "C" {
    #[doc = " Creates an image without allocating memory for the image (used in the new version of the library)."]
    #[doc = ""]
    #[doc = " @param   numcmpts    the number of components"]
    #[doc = " @param   cmptparms   the components parameters"]
    #[doc = " @param   clrspc      the image color space"]
    #[doc = ""]
    #[doc = " @return  a new image structure if successful, NULL otherwise."]
    pub fn opj_image_tile_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = " Allocator for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_free."]
    #[doc = ""]
    #[doc = " @param   size    number of bytes to allocate"]
    #[doc = ""]
    #[doc = " @return  a new pointer if successful, NULL otherwise."]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_alloc(size: OPJ_SIZE_T) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destructor for opj_image_t->comps[].data"]
    #[doc = " To be paired with opj_image_data_alloc."]
    #[doc = ""]
    #[doc = " @param   ptr    Pointer to free"]
    #[doc = ""]
    #[doc = " @since 2.2.0"]
    pub fn opj_image_data_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = " @param   p_is_input      if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = " @return  a stream object."]
    pub fn opj_stream_default_create(p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream."]
    #[doc = ""]
    #[doc = " @param   p_buffer_size  FIXME DOC"]
    #[doc = " @param   p_is_input      if set to true then the stream will be an input stream, an output stream else."]
    #[doc = ""]
    #[doc = " @return  a stream object."]
    pub fn opj_stream_create(p_buffer_size: OPJ_SIZE_T, p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Destroys a stream created by opj_create_stream. This function does NOT close the abstract stream. If needed the user must"]
    #[doc = " close its own implementation of the stream."]
    #[doc = ""]
    #[doc = " @param   p_stream    the stream to destroy."]
    pub fn opj_stream_destroy(p_stream: *mut opj_stream_t);
}
extern "C" {
    #[doc = " Sets the given function to be used as a read function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a read function."]
    pub fn opj_stream_set_read_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_read_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a write function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a write function."]
    pub fn opj_stream_set_write_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_write_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a skip function."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a skip function."]
    pub fn opj_stream_set_skip_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_skip_fn,
    );
}
extern "C" {
    #[doc = " Sets the given function to be used as a seek function, the stream is then seekable,"]
    #[doc = " using SEEK_SET behavior."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_function  the function to use a skip function."]
    pub fn opj_stream_set_seek_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_seek_fn,
    );
}
extern "C" {
    #[doc = " Sets the given data to be used as a user data for the stream."]
    #[doc = " @param       p_stream    the stream to modify"]
    #[doc = " @param       p_data      the data to set."]
    #[doc = " @param       p_function  the function to free p_data when opj_stream_destroy() is called."]
    pub fn opj_stream_set_user_data(
        p_stream: *mut opj_stream_t,
        p_data: *mut ::std::os::raw::c_void,
        p_function: opj_stream_free_user_data_fn,
    );
}
extern "C" {
    #[doc = " Sets the length of the user data for the stream."]
    #[doc = ""]
    #[doc = " @param p_stream    the stream to modify"]
    #[doc = " @param data_length length of the user_data."]
    pub fn opj_stream_set_user_data_length(p_stream: *mut opj_stream_t, data_length: OPJ_UINT64);
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with default parameters (helper function)"]
    #[doc = " @param fname             the filename of the file to stream"]
    #[doc = " @param p_is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_default_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Create a stream from a file identified with its filename with a specific buffer size"]
    #[doc = " @param fname             the filename of the file to stream"]
    #[doc = " @param p_buffer_size     size of the chunk used to stream"]
    #[doc = " @param p_is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_buffer_size: OPJ_SIZE_T,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = " Set the info handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_info_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the warning handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_warning_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the error handler use by openjpeg."]
    #[doc = " @param p_codec       the codec previously initialise"]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param p_user_data   client object where will be returned the message"]
    pub fn opj_set_error_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 decompression structure"]
    #[doc = " @param format        Decoder to select"]
    #[doc = ""]
    #[doc = " @return Returns a handle to a decompressor if successful, returns NULL otherwise"]
    pub fn opj_create_decompress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = " Destroy a decompressor handle"]
    #[doc = ""]
    #[doc = " @param   p_codec         decompressor handle to destroy"]
    pub fn opj_destroy_codec(p_codec: *mut opj_codec_t);
}
extern "C" {
    #[doc = " Read after the codestream if necessary"]
    #[doc = " @param   p_codec         the JPEG2000 codec to read."]
    #[doc = " @param   p_stream        the JPEG2000 stream."]
    pub fn opj_end_decompress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set decoding parameters to default values"]
    #[doc = " @param parameters Decompression parameters"]
    pub fn opj_set_default_decoder_parameters(parameters: *mut opj_dparameters_t);
}
extern "C" {
    #[doc = " Setup the decoder with decompression parameters provided by the user and with the message handler"]
    #[doc = " provided by the user."]
    #[doc = ""]
    #[doc = " @param p_codec       decompressor handler"]
    #[doc = " @param parameters    decompression parameters"]
    #[doc = ""]
    #[doc = " @return true         if the decoder is correctly set"]
    pub fn opj_setup_decoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_dparameters_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set strict decoding parameter for this decoder.  If strict decoding is enabled, partial bit"]
    #[doc = " streams will fail to decode.  If strict decoding is disabled, the decoder will decode partial"]
    #[doc = " bitstreams as much as possible without erroring"]
    #[doc = ""]
    #[doc = " @param p_codec       decompressor handler"]
    #[doc = " @param strict        OPJ_TRUE to enable strict decoding, OPJ_FALSE to disable"]
    #[doc = ""]
    #[doc = " @return true         if the decoder is correctly set"]
    pub fn opj_decoder_set_strict_mode(p_codec: *mut opj_codec_t, strict: OPJ_BOOL) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Allocates worker threads for the compressor/decompressor."]
    #[doc = ""]
    #[doc = " By default, only the main thread is used. If this function is not used,"]
    #[doc = " but the OPJ_NUM_THREADS environment variable is set, its value will be"]
    #[doc = " used to initialize the number of threads. The value can be either an integer"]
    #[doc = " number, or \"ALL_CPUS\". If OPJ_NUM_THREADS is set and this function is called,"]
    #[doc = " this function will override the behaviour of the environment variable."]
    #[doc = ""]
    #[doc = " This function must be called after opj_setup_decoder() and"]
    #[doc = " before opj_read_header() for the decoding side, or after opj_setup_encoder()"]
    #[doc = " and before opj_start_compress() for the encoding side."]
    #[doc = ""]
    #[doc = " @param p_codec       decompressor or compressor handler"]
    #[doc = " @param num_threads   number of threads."]
    #[doc = ""]
    #[doc = " @return OPJ_TRUE     if the function is successful."]
    pub fn opj_codec_set_threads(
        p_codec: *mut opj_codec_t,
        num_threads: ::std::os::raw::c_int,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decodes an image header."]
    #[doc = ""]
    #[doc = " @param   p_stream        the jpeg2000 stream."]
    #[doc = " @param   p_codec         the jpeg2000 codec to read."]
    #[doc = " @param   p_image         the image structure initialized with the characteristics of encoded image."]
    #[doc = ""]
    #[doc = " @return true             if the main header of the codestream and the JP2 header is correctly read."]
    pub fn opj_read_header(
        p_stream: *mut opj_stream_t,
        p_codec: *mut opj_codec_t,
        p_image: *mut *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Restrict the number of components to decode."]
    #[doc = ""]
    #[doc = " This function should be called after opj_read_header()."]
    #[doc = ""]
    #[doc = " This function enables to restrict the set of decoded components to the"]
    #[doc = " specified indices."]
    #[doc = " Note that the current implementation (apply_color_transforms == OPJ_FALSE)"]
    #[doc = " is such that neither the multi-component transform at codestream level,"]
    #[doc = " nor JP2 channel transformations will be applied."]
    #[doc = " Consequently the indices are relative to the codestream."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec to read."]
    #[doc = " @param   numcomps        Size of the comps_indices array."]
    #[doc = " @param   comps_indices   Array of numcomps values representing the indices"]
    #[doc = "                          of the components to decode (relative to the"]
    #[doc = "                          codestream, starting at 0)"]
    #[doc = " @param   apply_color_transforms Whether multi-component transform at codestream level"]
    #[doc = "                                 or JP2 channel transformations should be applied."]
    #[doc = "                                 Currently this parameter should be set to OPJ_FALSE."]
    #[doc = "                                 Setting it to OPJ_TRUE will result in an error."]
    #[doc = ""]
    #[doc = " @return OPJ_TRUE         in case of success."]
    pub fn opj_set_decoded_components(
        p_codec: *mut opj_codec_t,
        numcomps: OPJ_UINT32,
        comps_indices: *const OPJ_UINT32,
        apply_color_transforms: OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading."]
    #[doc = ""]
    #[doc = " The coordinates passed to this function should be expressed in the reference grid,"]
    #[doc = " that is to say at the highest resolution level, even if requesting the image at lower"]
    #[doc = " resolution levels."]
    #[doc = ""]
    #[doc = " Generally opj_set_decode_area() should be followed by opj_decode(), and the"]
    #[doc = " codec cannot be re-used."]
    #[doc = " In the particular case of an image made of a single tile, several sequences of"]
    #[doc = " calls to opoj_set_decode_area() and opj_decode() are allowed, and will bring"]
    #[doc = " performance improvements when reading an image by chunks."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_image         the decoded image previously set by opj_read_header"]
    #[doc = " @param   p_start_x       the left position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_end_x         the right position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_start_y       the up position of the rectangle to decode (in image coordinates)."]
    #[doc = " @param   p_end_y         the bottom position of the rectangle to decode (in image coordinates)."]
    #[doc = ""]
    #[doc = " @return  true            if the area could be set."]
    pub fn opj_set_decode_area(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_start_x: OPJ_INT32,
        p_start_y: OPJ_INT32,
        p_end_x: OPJ_INT32,
        p_end_y: OPJ_INT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Decode an image from a JPEG-2000 codestream"]
    #[doc = ""]
    #[doc = " @param p_decompressor    decompressor handle"]
    #[doc = " @param p_stream          Input buffer stream"]
    #[doc = " @param p_image           the decoded image"]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_decode(
        p_decompressor: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Get the decoded tile from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_stream        input stream"]
    #[doc = " @param   p_image         output image"]
    #[doc = " @param   tile_index      index of the tile which will be decode"]
    #[doc = ""]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_get_decoded_tile(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
        tile_index: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Set the resolution factor of the decoded image"]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   res_factor      resolution factor to set"]
    #[doc = ""]
    #[doc = " @return                  true if success, otherwise false"]
    pub fn opj_set_decoded_resolution_factor(
        p_codec: *mut opj_codec_t,
        res_factor: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Writes a tile with the given data."]
    #[doc = ""]
    #[doc = " @param   p_codec             the jpeg2000 codec."]
    #[doc = " @param   p_tile_index        the index of the tile to write. At the moment, the tiles must be written from 0 to n-1 in sequence."]
    #[doc = " @param   p_data              pointer to the data to write. Data is arranged in sequence, data_comp0, then data_comp1, then ... NO INTERLEAVING should be set."]
    #[doc = " @param   p_data_size         this value os used to make sure the data being written is correct. The size must be equal to the sum for each component of"]
    #[doc = "                              tile_width * tile_height * component_size. component_size can be 1,2 or 4 bytes, depending on the precision of the given component."]
    #[doc = " @param   p_stream            the stream to write data to."]
    #[doc = ""]
    #[doc = " @return  true if the data could be written."]
    pub fn opj_write_tile(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile header. This function is compulsory and allows one to know the size of the tile that will be decoded."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_tile_index    pointer to a value that will hold the index of the tile being decoded, in case of success."]
    #[doc = " @param   p_data_size     pointer to a value that will hold the maximum size of the decoded data, in case of success. In case"]
    #[doc = "                          of truncated codestreams, the actual number of bytes decoded may be lower. The computation of the size is the same"]
    #[doc = "                          as depicted in opj_write_tile."]
    #[doc = " @param   p_tile_x0       pointer to a value that will hold the x0 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_y0       pointer to a value that will hold the y0 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_x1       pointer to a value that will hold the x1 pos of the tile (in the image)."]
    #[doc = " @param   p_tile_y1       pointer to a value that will hold the y1 pos of the tile (in the image)."]
    #[doc = " @param   p_nb_comps      pointer to a value that will hold the number of components in the tile."]
    #[doc = " @param   p_should_go_on  pointer to a boolean that will hold the fact that the decoding should go on. In case the"]
    #[doc = "                          codestream is over at the time of the call, the value will be set to false. The user should then stop"]
    #[doc = "                          the decoding."]
    #[doc = " @param   p_stream        the stream to decode."]
    #[doc = " @return  true            if the tile header could be decoded. In case the decoding should end, the returned value is still true."]
    #[doc = "                          returning false may be the result of a shortage of memory or an internal error."]
    pub fn opj_read_tile_header(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_tile_index: *mut OPJ_UINT32,
        p_data_size: *mut OPJ_UINT32,
        p_tile_x0: *mut OPJ_INT32,
        p_tile_y0: *mut OPJ_INT32,
        p_tile_x1: *mut OPJ_INT32,
        p_tile_y1: *mut OPJ_INT32,
        p_nb_comps: *mut OPJ_UINT32,
        p_should_go_on: *mut OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Reads a tile data. This function is compulsory and allows one to decode tile data. opj_read_tile_header should be called before."]
    #[doc = " The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile."]
    #[doc = ""]
    #[doc = " Note: opj_decode_tile_data() should not be used together with opj_set_decoded_components()."]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   p_tile_index    the index of the tile being decoded, this should be the value set by opj_read_tile_header."]
    #[doc = " @param   p_data          pointer to a memory block that will hold the decoded data."]
    #[doc = " @param   p_data_size     size of p_data. p_data_size should be bigger or equal to the value set by opj_read_tile_header."]
    #[doc = " @param   p_stream        the stream to decode."]
    #[doc = ""]
    #[doc = " @return  true            if the data could be decoded."]
    pub fn opj_decode_tile_data(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 compression structure"]
    #[doc = " @param   format      Coder to select"]
    #[doc = " @return              Returns a handle to a compressor if successful, returns NULL otherwise"]
    pub fn opj_create_compress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = "Set encoding parameters to default values, that means :"]
    #[doc = "<ul>"]
    #[doc = "<li>Lossless"]
    #[doc = "<li>1 tile"]
    #[doc = "<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)"]
    #[doc = "<li>Size of code-block : 64 x 64"]
    #[doc = "<li>Number of resolutions: 6"]
    #[doc = "<li>No SOP marker in the codestream"]
    #[doc = "<li>No EPH marker in the codestream"]
    #[doc = "<li>No sub-sampling in x or y direction"]
    #[doc = "<li>No mode switch activated"]
    #[doc = "<li>Progression order: LRCP"]
    #[doc = "<li>No index file"]
    #[doc = "<li>No ROI upshifted"]
    #[doc = "<li>No offset of the origin of the image"]
    #[doc = "<li>No offset of the origin of the tiles"]
    #[doc = "<li>Reversible DWT 5-3"]
    #[doc = "</ul>"]
    #[doc = "@param parameters Compression parameters"]
    pub fn opj_set_default_encoder_parameters(parameters: *mut opj_cparameters_t);
}
extern "C" {
    #[doc = " Setup the encoder parameters using the current image and using user parameters."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param parameters    Compression parameters"]
    #[doc = " @param image         Input filled image"]
    pub fn opj_setup_encoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_cparameters_t,
        image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Specify extra options for the encoder."]
    #[doc = ""]
    #[doc = " This may be called after opj_setup_encoder() and before opj_start_compress()"]
    #[doc = ""]
    #[doc = " This is the way to add new options in a fully ABI compatible way, without"]
    #[doc = " extending the opj_cparameters_t structure."]
    #[doc = ""]
    #[doc = " Currently supported options are:"]
    #[doc = " <ul>"]
    #[doc = " <li>PLT=YES/NO. Defaults to NO. If set to YES, PLT marker segments,"]
    #[doc = "     indicating the length of each packet in the tile-part header, will be"]
    #[doc = "     written. Since 2.4.0</li>"]
    #[doc = " <li>TLM=YES/NO. Defaults to NO (except for Cinema and IMF profiles)."]
    #[doc = "     If set to YES, TLM marker segments, indicating the length of each"]
    #[doc = "     tile-part part will be written. Since 2.4.0</li>"]
    #[doc = " <li>GUARD_BITS=value. Number of guard bits in [0,7] range. Default value is 2."]
    #[doc = "     1 may be used sometimes (like in SMPTE DCP Bv2.1 Application Profile for 2K images)."]
    #[doc = "     Since 2.5.0</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param p_options     Compression options. This should be a NULL terminated"]
    #[doc = "                      array of strings. Each string is of the form KEY=VALUE."]
    #[doc = ""]
    #[doc = " @return OPJ_TRUE in case of success."]
    #[doc = " @since 2.4.0"]
    pub fn opj_encoder_set_extra_options(
        p_codec: *mut opj_codec_t,
        p_options: *const *const ::std::os::raw::c_char,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Start to compress the current image."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param p_image       Input filled image"]
    #[doc = " @param p_stream      Input stgream"]
    pub fn opj_start_compress(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " End to compress the current image."]
    #[doc = " @param p_codec       Compressor handle"]
    #[doc = " @param p_stream      Input stgream"]
    pub fn opj_end_compress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Encode an image into a JPEG-2000 codestream"]
    #[doc = " @param p_codec       compressor handle"]
    #[doc = " @param p_stream      Output buffer stream"]
    #[doc = ""]
    #[doc = " @return              Returns true if successful, returns false otherwise"]
    pub fn opj_encode(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Destroy Codestream information after compression or decompression"]
    #[doc = "@param cstr_info Codestream information structure"]
    pub fn opj_destroy_cstr_info(cstr_info: *mut *mut opj_codestream_info_v2_t);
}
extern "C" {
    #[doc = " Dump the codec information into the output stream"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = " @param   info_flag       type of information dump."]
    #[doc = " @param   output_stream   output stream where dump the information gotten from the codec."]
    #[doc = ""]
    pub fn opj_dump_codec(
        p_codec: *mut opj_codec_t,
        info_flag: OPJ_INT32,
        output_stream: *mut FILE,
    );
}
extern "C" {
    #[doc = " Get the codestream information from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a codestream information structure."]
    #[doc = ""]
    pub fn opj_get_cstr_info(p_codec: *mut opj_codec_t) -> *mut opj_codestream_info_v2_t;
}
extern "C" {
    #[doc = " Get the codestream index from the codec"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a codestream index structure."]
    #[doc = ""]
    pub fn opj_get_cstr_index(p_codec: *mut opj_codec_t) -> *mut opj_codestream_index_t;
}
extern "C" {
    pub fn opj_destroy_cstr_index(p_cstr_index: *mut *mut opj_codestream_index_t);
}
extern "C" {
    #[doc = " Get the JP2 file information from the codec FIXME"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a JP2 metadata structure."]
    #[doc = ""]
    pub fn opj_get_jp2_metadata(p_codec: *mut opj_codec_t) -> *mut opj_jp2_metadata_t;
}
extern "C" {
    #[doc = " Get the JP2 file index from the codec FIXME"]
    #[doc = ""]
    #[doc = " @param   p_codec         the jpeg2000 codec."]
    #[doc = ""]
    #[doc = " @return                  a pointer to a JP2 index structure."]
    #[doc = ""]
    pub fn opj_get_jp2_index(p_codec: *mut opj_codec_t) -> *mut opj_jp2_index_t;
}
extern "C" {
    #[doc = " Sets the MCT matrix to use."]
    #[doc = ""]
    #[doc = " @param   parameters      the parameters to change."]
    #[doc = " @param   pEncodingMatrix the encoding matrix."]
    #[doc = " @param   p_dc_shift      the dc shift coefficients to use."]
    #[doc = " @param   pNbComp         the number of components of the image."]
    #[doc = ""]
    #[doc = " @return  true if the parameters could be set."]
    pub fn opj_set_MCT(
        parameters: *mut opj_cparameters_t,
        pEncodingMatrix: *mut OPJ_FLOAT32,
        p_dc_shift: *mut OPJ_INT32,
        pNbComp: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Returns if the library is built with thread support."]
    #[doc = " OPJ_TRUE if mutex, condition, thread, thread pool are available."]
    pub fn opj_has_thread_support() -> OPJ_BOOL;
}
extern "C" {
    #[doc = " Return the number of virtual CPUs"]
    pub fn opj_get_num_cpus() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
